<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Lists
</TITLE>
</HEAD>
<BODY >
<A HREF="cfbook008.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="cfbook010.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><FONT COLOR=black><A NAME="htoc99">Chapter&nbsp;8</A>&nbsp;&nbsp;Lists</FONT></H1>
<A NAME="@default450"></A>
<A NAME="@default451"></A>
<A NAME="toc91"></A>
<H2><FONT COLOR=black><A NAME="htoc100">8.1</A>&nbsp;&nbsp;A list is a sequence</FONT></H2>
<FONT COLOR=black>Like a string, a <B>list</B> is a sequence of values. In a string, the
values are characters; in a list, they can be any type. The values in
list are called <B>elements</B> or sometimes <B>items</B>.<BR>
<BR>
<A NAME="@default452"></A>
<A NAME="@default453"></A>
<A NAME="@default454"></A><BR>
<BR>
There are several ways to create a new list; the simplest is to
enclose the elements in square brackets (<CODE>[</CODE> and <CODE>]</CODE>):
</FONT><PRE><FONT SIZE=4 COLOR=blue>
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
</FONT></PRE><FONT COLOR=black>The first example is a list of four integers. The second is a list of
three strings. The elements of a list don't have to be the same type.
The following list contains a string, a float, an integer, and
(lo!) another list:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
['spam', 2.0, 5, [10, 20]]
</FONT></PRE><FONT COLOR=black>A list within another list is <B>nested</B>.<BR>
<BR>
<A NAME="@default455"></A>
<A NAME="@default456"></A><BR>
<BR>
A list that contains no elements is
called an empty list; you can create one with empty
brackets, <CODE>[]</CODE>.<BR>
<BR>
<A NAME="@default457"></A>
<A NAME="@default458"></A><BR>
<BR>
As you might expect, you can assign list values to variables:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; numbers = [17, 123]
&gt;&gt;&gt; empty = []
&gt;&gt;&gt; print cheeses, numbers, empty
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
</FONT></PRE>
<A NAME="@default459"></A>
<A NAME="toc92"></A>
<H2><FONT COLOR=black><A NAME="htoc101">8.2</A>&nbsp;&nbsp;Lists are mutable</FONT></H2>
<A NAME="@default460"></A>
<A NAME="@default461"></A>
<A NAME="@default462"></A>
<A NAME="@default463"></A>
<A NAME="@default464"></A>
<FONT COLOR=black>The syntax for accessing the elements of a list is the same as for
accessing the characters of a string---the bracket operator. The
expression inside the brackets specifies the index. Remember that the
indices start at 0:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; print cheeses[0]
Cheddar
</FONT></PRE><FONT COLOR=black>Unlike strings, lists are mutable because you can change the order 
of items in a list or reassign an item in a list. 
When the bracket operator appears on the left side of an assignment, 
it identifies the element of the list that will be assigned.</FONT><BR>
<BR>
<A NAME="@default465"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; numbers = [17, 123]
&gt;&gt;&gt; numbers[1] = 5
&gt;&gt;&gt; print numbers
[17, 5]
</FONT></PRE><FONT COLOR=black>The one-eth element of <TT>numbers</TT>, which
used to be 123, is now 5.<BR>
<BR>
<A NAME="@default466"></A>
<A NAME="@default467"></A><BR>
<BR>
You can think of a list as a relationship between indices and
elements. This relationship is called a <B>mapping</B>; each index
``maps to'' one of the elements. <BR>
<BR>
<A NAME="@default468"></A>
<A NAME="@default469"></A><BR>
<BR>
List indices work the same way as string indices:
</FONT><UL><LI><FONT COLOR=black>Any integer expression can be used as an index.</FONT><BR>
<BR>
<LI><FONT COLOR=black>If you try to read or write an element that does not exist, you
get an <TT>IndexError</TT>.</FONT><BR>
<BR>
<A NAME="@default470"></A>
<A NAME="@default471"></A><BR>
<BR>
<LI><FONT COLOR=black>If an index has a negative value, it counts backward from the
end of the list.</FONT></UL>
<A NAME="@default472"></A>
<A NAME="@default473"></A>
<A NAME="@default474"></A>
<A NAME="@default475"></A>
<A NAME="@default476"></A>
<FONT COLOR=black>The <TT>in</TT> operator also works on lists.
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; cheeses = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; 'Edam' in cheeses
True
&gt;&gt;&gt; 'Brie' in cheeses
False
</FONT></PRE>
<A NAME="toc93"></A>
<H2><FONT COLOR=black><A NAME="htoc102">8.3</A>&nbsp;&nbsp;Traversing a list</FONT></H2>
<A NAME="@default477"></A>
<A NAME="@default478"></A>
<A NAME="@default479"></A>
<A NAME="@default480"></A>
<A NAME="@default481"></A>
<FONT COLOR=black>The most common way to traverse the elements of a list is
with a <TT>for</TT> loop. The syntax is the same as for strings:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
for cheese in cheeses:
    print cheese
</FONT></PRE><FONT COLOR=black>This works well if you only need to read the elements of the
list. But if you want to write or update the elements, you
need the indices. A common way to do that is to combine
the functions <TT>range</TT> and <TT>len</TT>:</FONT><BR>
<BR>
<A NAME="@default482"></A>
<A NAME="@default483"></A>
<PRE><FONT SIZE=4 COLOR=blue>
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
</FONT></PRE><FONT COLOR=black>This loop traverses the list and updates each element. <TT>len</TT>
returns the number of elements in the list. <TT>range</TT> returns
a list of indices from 0 to <I>n</I>-1, where <I>n</I> is the length of
the list. Each time through the loop <TT>i</TT> gets the index
of the next element. The assignment statement in the body uses
<TT>i</TT> to read the old value of the element and to assign the
new value.<BR>
<BR>
<A NAME="@default484"></A>
<A NAME="@default485"></A><BR>
<BR>
A <TT>for</TT> loop over an empty list never executes the body:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
for x in empty:
    print 'This never happens.'
</FONT></PRE><FONT COLOR=black>Although a list can contain another list, the nested
list still counts as a single element. The length of this list is
four:</FONT><BR>
<BR>
<A NAME="@default486"></A>
<A NAME="@default487"></A>
<PRE><FONT SIZE=4 COLOR=blue>
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</FONT></PRE>
<A NAME="toc94"></A>
<H2><FONT COLOR=black><A NAME="htoc103">8.4</A>&nbsp;&nbsp;List operations</FONT></H2>
<A NAME="@default488"></A>
<FONT COLOR=black>The <TT>+</TT> operator concatenates lists:</FONT><BR>
<BR>
<A NAME="@default489"></A>
<A NAME="@default490"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; print c
[1, 2, 3, 4, 5, 6]
</FONT></PRE><FONT COLOR=black>Similarly, the <TT>*</TT> operator repeats a list a given number of times:</FONT><BR>
<BR>
<A NAME="@default491"></A>
<A NAME="@default492"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</FONT></PRE><FONT COLOR=black>The first example repeats <TT>[0]</TT> four times. The second example
repeats the list <TT>[1, 2, 3]</TT> three times.</FONT><BR>
<BR>
<A NAME="toc95"></A>
<H2><FONT COLOR=black><A NAME="htoc104">8.5</A>&nbsp;&nbsp;List slices</FONT></H2>
<A NAME="@default493"></A>
<A NAME="@default494"></A>
<A NAME="@default495"></A>
<A NAME="@default496"></A>
<A NAME="@default497"></A>
<FONT COLOR=black>The slice operator also works on lists:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3]
['b', 'c']
&gt;&gt;&gt; t[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; t[3:]
['d', 'e', 'f']
</FONT></PRE><FONT COLOR=black>If you omit the first index, the slice starts at the beginning.
If you omit the second, the slice goes to the end. So if you
omit both, the slice is a copy of the whole list.</FONT><BR>
<BR>
<A NAME="@default498"></A>
<A NAME="@default499"></A>
<A NAME="@default500"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t[:]
['a', 'b', 'c', 'd', 'e', 'f']
</FONT></PRE><FONT COLOR=black>Since lists are mutable, it is often useful to make a copy
before performing operations that fold, spindle or mutilate
lists.<BR>
<BR>
<A NAME="@default501"></A><BR>
<BR>
A slice operator on the left side of an assignment
can update multiple elements:</FONT><BR>
<BR>
<A NAME="@default502"></A>
<A NAME="@default503"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3] = ['x', 'y']
&gt;&gt;&gt; print t
['a', 'x', 'y', 'd', 'e', 'f']
</FONT></PRE>
<A NAME="toc96"></A>
<H2><FONT COLOR=black><A NAME="htoc105">8.6</A>&nbsp;&nbsp;List methods</FONT></H2>
<A NAME="@default504"></A>
<A NAME="@default505"></A>
<FONT COLOR=black>Python provides methods that operate on lists. For example,
<TT>append</TT> adds a new element to the end of a list:</FONT><BR>
<BR>
<A NAME="@default506"></A>
<A NAME="@default507"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.append('d')
&gt;&gt;&gt; print t
['a', 'b', 'c', 'd']
</FONT></PRE><FONT COLOR=black><TT>extend</TT> takes a list as an argument and appends all of
the elements:</FONT><BR>
<BR>
<A NAME="@default508"></A>
<A NAME="@default509"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t1 = ['a', 'b', 'c']
&gt;&gt;&gt; t2 = ['d', 'e']
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; print t1
['a', 'b', 'c', 'd', 'e']
</FONT></PRE><FONT COLOR=black>This example leaves <TT>t2</TT> unmodified.<BR>
<BR>
<TT>sort</TT> arranges the elements of the list from low to high:</FONT><BR>
<BR>
<A NAME="@default510"></A>
<A NAME="@default511"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; print t
['a', 'b', 'c', 'd', 'e']
</FONT></PRE><FONT COLOR=black>Most list methods are void; they modify the list and return <TT>None</TT>.
If you accidentally write <TT>t = t.sort()</TT>, you will be disappointed
with the result.</FONT><BR>
<BR>
<A NAME="@default512"></A>
<A NAME="@default513"></A>
<A NAME="@default514"></A>
<A NAME="@default515"></A><BR>
<BR>
<A NAME="toc97"></A>
<H2><FONT COLOR=black><A NAME="htoc106">8.7</A>&nbsp;&nbsp;Deleting elements</FONT></H2>
<A NAME="@default516"></A>
<A NAME="@default517"></A>
<FONT COLOR=black>There are several ways to delete elements from a list. If you
know the index of the element you want, you can use
<TT>pop</TT>:</FONT><BR>
<BR>
<A NAME="@default518"></A>
<A NAME="@default519"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; print t
['a', 'c']
&gt;&gt;&gt; print x
b
</FONT></PRE><FONT COLOR=black><TT>pop</TT> modifies the list and returns the element that was removed.
If you don't provide an index, it deletes and returns the
last element.<BR>
<BR>
If you don't need the removed value, you can use the <TT>del</TT>
operator:</FONT><BR>
<BR>
<A NAME="@default520"></A>
<A NAME="@default521"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; print t
['a', 'c']
</FONT></PRE>
<FONT COLOR=black>If you know the element you want to remove (but not the index), you
can use <TT>remove</TT>:</FONT><BR>
<BR>
<A NAME="@default522"></A>
<A NAME="@default523"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.remove('b')
&gt;&gt;&gt; print t
['a', 'c']
</FONT></PRE><FONT COLOR=black>The return value from <TT>remove</TT> is <TT>None</TT>.<BR>
<BR>
<A NAME="@default524"></A>
<A NAME="@default525"></A><BR>
<BR>
To remove more than one element, you can use <TT>del</TT> with
a slice index:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; print t
['a', 'f']
</FONT></PRE><FONT COLOR=black>As usual, the slice selects all the elements up to, but not
including, the second index.</FONT><BR>
<BR>
<A NAME="toc98"></A>
<H2><FONT COLOR=black><A NAME="htoc107">8.8</A>&nbsp;&nbsp;Lists and functions</FONT></H2>
<FONT COLOR=black>There are a number of built-in functions that can be used on lists
that allow you to quickly look through a list without
writing your own loops:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; nums = [3, 41, 12, 9, 74, 15]
&gt;&gt;&gt; print len(nums)
6
&gt;&gt;&gt; print max(nums)
74
&gt;&gt;&gt; print min(nums)
3
&gt;&gt;&gt; print sum(nums)
154
&gt;&gt;&gt; print sum(nums)/len(nums)
25
</FONT></PRE><FONT COLOR=black>The <TT>sum()</TT> function only works when the list elements are numbers.
The other functions (<TT>max()</TT>, <TT>len()</TT>, etc.) work with lists of
strings and other types that can be comparable.<BR>
<BR>
We could rewrite an earlier program that computed the average of 
a list of numbers entered by the user using a list.<BR>
<BR>
First, the program to compute an average without a list:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
total = 0
count = 0
while ( True ) :
    inp = raw_input('Enter a number: ')
    if inp == 'done' : break
    value = float(inp)
    total = total + value
    count = count + 1

average = total / count
print 'Average:', average
</FONT></PRE><FONT COLOR=black>In this program, we have <TT>count</TT> and <TT>sum</TT> variables to 
keep the number and running total of the user's numbers as 
we repeatedly prompt the user for a number.<BR>
<BR>
We could simply remember each number as the user entered it 
and use built-in functions to compute the sum and count at
the end.
</FONT><PRE><FONT SIZE=4 COLOR=blue>
numlist = list()
while ( True ) :
    inp = raw_input('Enter a number: ')
    if inp == 'done' : break
    value = float(inp)
    numlist.append(value)

average = sum(numlist) / len(numlist)
print 'Average:', average
</FONT></PRE><FONT COLOR=black>We make an empty list before the loop starts, and then each time we have 
a number, we append it to the list. At the end of
the program, we simply compute the sum of the numbers in the 
list and divide it by the count of the numbers in the
list to come up with the average.</FONT><BR>
<BR>
<A NAME="toc99"></A>
<H2><FONT COLOR=black><A NAME="htoc108">8.9</A>&nbsp;&nbsp;Lists and strings</FONT></H2>
<A NAME="@default526"></A>
<A NAME="@default527"></A>
<A NAME="@default528"></A>
<FONT COLOR=black>A string is a sequence of characters and a list is a sequence
of values, but a list of characters is not the same as a
string. To convert from a string to a list of characters,
you can use <TT>list</TT>:</FONT><BR>
<BR>
<A NAME="@default529"></A>
<A NAME="@default530"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; s = 'spam'
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; print t
['s', 'p', 'a', 'm']
</FONT></PRE><FONT COLOR=black>Because <TT>list</TT> is the name of a built-in function, you should
avoid using it as a variable name. I also avoid <TT>l</TT> because
it looks too much like <TT>1</TT>. So that's why I use <TT>t</TT>.<BR>
<BR>
The <TT>list</TT> function breaks a string into individual letters. If
you want to break a string into words, you can use the <TT>split</TT>
method:</FONT><BR>
<BR>
<A NAME="@default531"></A>
<A NAME="@default532"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; s = 'pining for the fjords'
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; print t
['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; print t[2]
the
</FONT></PRE><FONT COLOR=black>Once you have used <TT>split</TT> to break the string into 
a list of tokens, you can use the index operator (square
bracket) to look at a particular word in the list.<BR>
<BR>
You can call <TT>split</TT> with 
an optional argument called a <B>delimiter</B> specifies which
characters to use as word boundaries.
The following example
uses a hyphen as a delimiter:</FONT><BR>
<BR>
<A NAME="@default533"></A>
<A NAME="@default534"></A>
<A NAME="@default535"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; s = 'spam-spam-spam'
&gt;&gt;&gt; delimiter = '-'
&gt;&gt;&gt; s.split(delimiter)
['spam', 'spam', 'spam']
</FONT></PRE><FONT COLOR=black><TT>join</TT> is the inverse of <TT>split</TT>. It
takes a list of strings and
concatenates the elements. <TT>join</TT> is a string method,
so you have to invoke it on the delimiter and pass the
list as a parameter:</FONT><BR>
<BR>
<A NAME="@default536"></A>
<A NAME="@default537"></A>
<A NAME="@default538"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t = ['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; delimiter = ' '
&gt;&gt;&gt; delimiter.join(t)
'pining for the fjords'
</FONT></PRE><FONT COLOR=black>In this case the delimiter is a space character, so
<TT>join</TT> puts a space between words. To concatenate
strings without spaces, you can use the empty string,
<CODE>''</CODE>, as a delimiter. </FONT><BR>
<BR>
<A NAME="@default539"></A>
<A NAME="@default540"></A><BR>
<BR>
<A NAME="toc100"></A>
<H2><FONT COLOR=black><A NAME="htoc109">8.10</A>&nbsp;&nbsp;Parsing lines</FONT></H2>
<FONT COLOR=black>Usually when we are reading a file 
we want to do something to the lines other than just 
printing the whole line. Often we want to find the ``interesting
lines'' and then <B>parse</B> the line to find some interesting
<EM>part</EM> of the line. What if we wanted to print out the day of the 
week from those lines that start with ``From ''.
</FONT><PRE><FONT SIZE=4 COLOR=blue>
From stephen.marquard@uct.ac.za <B> Sat</B> Jan  5 09:14:16 2008
</FONT></PRE><FONT SIZE=4>

</FONT><FONT SIZE=3 COLOR=black>The <TT>split</TT> method is very effective when faced with this 
kind of problem.
We can write a small program that looks for lines where the 
line starts with ``From '' and then <TT>split</TT> those lines 
and then print out the third word in the line:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if not line.startswith('From ') : continue
    words = line.split()
    print words[2]
</FONT></PRE><FONT COLOR=black>We also use the contracted form of the <TT>if</TT>
statement where we put the <TT>continue </TT> on the
same line as the <TT>if</TT>. This contracted form
of the <TT>if</TT> functions the same as if the
<TT>continue</TT> were on the next line and indented.<BR>
<BR>
The program produces the following output:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
Sat
Fri
Fri
Fri
    ...
</FONT></PRE><FONT COLOR=black>Later, we will learn increasingly sophisticated techniques for
picking the lines to work on and how we pull those lines apart
to find the exact bit of information we are looking for.</FONT><BR>
<BR>
<A NAME="toc101"></A>
<H2><FONT COLOR=black><A NAME="htoc110">8.11</A>&nbsp;&nbsp;Objects and values</FONT></H2>
<A NAME="@default541"></A>
<A NAME="@default542"></A>
<FONT COLOR=black>If we execute these assignment statements:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
a = 'banana'
b = 'banana'
</FONT></PRE><FONT COLOR=black>We know that <TT>a</TT> and <TT>b</TT> both refer to a
string, but we don't
know whether they refer to the <EM>same</EM> string.
There are two possible states:</FONT><BR>
<BR>
<A NAME="@default543"></A><BR>
<DIV ALIGN=center><FONT COLOR=black><IMG SRC="cfbook012.png"></FONT></DIV><FONT COLOR=black>
<BR>
In one case, <TT>a</TT> and <TT>b</TT> refer to two different objects that
have the same value. In the second case, they refer to the same
object.<BR>
<BR>
<A NAME="@default544"></A>
<A NAME="@default545"></A><BR>
<BR>
To check whether two variables refer to the same object, you can
use the <TT>is</TT> operator.
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; a = 'banana'
&gt;&gt;&gt; b = 'banana'
&gt;&gt;&gt; a is b
True
</FONT></PRE><FONT COLOR=black>In this example, Python only created one string object,
and both <TT>a</TT> and <TT>b</TT> refer to it.<BR>
<BR>
But when you create two lists, you get two objects:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False
</FONT></PRE>
<FONT COLOR=black>In this case we would say that the two lists are <B>equivalent</B>,
because they have the same elements, but not <B>identical</B>, because
they are not the same object. If two objects are identical, they are
also equivalent, but if they are equivalent, they are not necessarily
identical.<BR>
<BR>
<A NAME="@default546"></A>
<A NAME="@default547"></A><BR>
<BR>
Until now, we have been using ``object'' and ``value''
interchangeably, but it is more precise to say that an object has a
value. If you execute <TT>a = [1,2,3]</TT>, <TT>a</TT> refers to a list
object whose value is a particular sequence of elements. If another
list has the same elements, we would say it has the same value.</FONT><BR>
<BR>
<A NAME="@default548"></A>
<A NAME="@default549"></A><BR>
<BR>
<A NAME="toc102"></A>
<H2><FONT COLOR=black><A NAME="htoc111">8.12</A>&nbsp;&nbsp;Aliasing</FONT></H2>
<A NAME="@default550"></A>
<A NAME="@default551"></A>
<FONT COLOR=black>If <TT>a</TT> refers to an object and you assign <TT>b = a</TT>,
then both variables refer to the same object:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True
</FONT></PRE>
<FONT COLOR=black>The association of a variable with an object is called a <B>reference</B>. In this example, there are two references to the same
object.<BR>
<BR>
<A NAME="@default552"></A><BR>
<BR>
An object with more than one reference has more
than one name, so we say that the object is <B>aliased</B>.<BR>
<BR>
<A NAME="@default553"></A><BR>
<BR>
If the aliased object is mutable, 
changes made with one alias affect
the other:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; b[0] = 17
&gt;&gt;&gt; print a
[17, 2, 3]
</FONT></PRE><FONT COLOR=black>Although this behavior can be useful, it is error-prone. In general,
it is safer to avoid aliasing when you are working with mutable
objects.<BR>
<BR>
<A NAME="@default554"></A><BR>
<BR>
For immutable objects like strings, aliasing is not as much of a
problem. In this example:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
a = 'banana'
b = 'banana'
</FONT></PRE><FONT COLOR=black>It almost never makes a difference whether <TT>a</TT> and <TT>b</TT> refer
to the same string or not.</FONT><BR>
<BR>
<A NAME="toc103"></A>
<H2><FONT COLOR=black><A NAME="htoc112">8.13</A>&nbsp;&nbsp;List arguments</FONT></H2>
<A NAME="@default555"></A>
<A NAME="@default556"></A>
<A NAME="@default557"></A>
<A NAME="@default558"></A>
<A NAME="@default559"></A>
<FONT COLOR=black>When you pass a list to a function, the function gets a reference
to the list.
If the function modifies a list parameter, the caller sees the change.
For example, <CODE>delete_head</CODE> removes the first element from a list:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
def delete_head(t):
    del t[0]
</FONT></PRE><FONT COLOR=black>Here's how it is used:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; delete_head(letters)
&gt;&gt;&gt; print letters
['b', 'c']
</FONT></PRE><FONT COLOR=black>The parameter <TT>t</TT> and the variable <TT>letters</TT> are
aliases for the same object. <BR>
<BR>
It is important to distinguish between operations that
modify lists and operations that create new lists. For
example, the <TT>append</TT> method modifies a list, but the
<TT>+</TT> operator creates a new list:</FONT><BR>
<BR>
<A NAME="@default560"></A>
<A NAME="@default561"></A>
<A NAME="@default562"></A>
<A NAME="@default563"></A>
<PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; print t1
[1, 2, 3]
&gt;&gt;&gt; print t2
None

&gt;&gt;&gt; t3 = t1 + [3]
&gt;&gt;&gt; print t3
[1, 2, 3]
&gt;&gt;&gt; t2 is t3
False
</FONT></PRE>
<FONT COLOR=black>This difference is important when you write functions that
are supposed to modify lists. For example, this function
<EM>does not</EM> delete the head of a list:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
def bad_delete_head(t):
    t = t[1:]              # WRONG!
</FONT></PRE>
<FONT COLOR=black>The slice operator creates a new list and the assignment
makes <TT>t</TT> refer to it, but none of that has any effect
on the list that was passed as an argument.<BR>
<BR>
<A NAME="@default564"></A>
<A NAME="@default565"></A><BR>
<BR>
An alternative is to write a function that creates and
returns a new list. For
example, <TT>tail</TT> returns all but the first
element of a list:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
def tail(t):
    return t[1:]
</FONT></PRE><FONT COLOR=black>This function leaves the original list unmodified.
Here's how it is used:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; rest = tail(letters)
&gt;&gt;&gt; print rest
['b', 'c']
</FONT></PRE><BR>
<DIV ALIGN=left><FONT COLOR=black><B>Exercise&nbsp;1</B>&nbsp;&nbsp;<BR>
<BR>
<EM>Write a function called <TT>chop</TT> that takes a list and modifies
it, removing the first and last elements, and returns <TT>None</TT>.<BR>
<BR>
Then write a function called <TT>middle</TT> that takes a list and
returns a new list that contains all but the first and last
elements.</EM></FONT></DIV><BR>
<A NAME="toc104"></A>
<H2><FONT COLOR=black><A NAME="htoc113">8.14</A>&nbsp;&nbsp;Debugging</FONT></H2>
<A NAME="@default566"></A>
<FONT COLOR=black>Careless use of lists (and other mutable objects)
can lead to long hours of debugging. Here are some common
pitfalls and ways to avoid them:
</FONT><OL type=1><LI><FONT COLOR=black>Don't forget that most list methods modify the argument and
 return <TT>None</TT>. This is the opposite of the string methods,
 which return a new string and leave the original alone.<BR>
<BR>
If you are used to writing string code like this:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
word = word.strip()
</FONT></PRE>
<FONT COLOR=black>It is tempting to write list code like this:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
t = t.sort()           # WRONG!
</FONT></PRE>
<A NAME="@default567"></A>
<A NAME="@default568"></A>
<FONT COLOR=black>Because <TT>sort</TT> returns <TT>None</TT>, the
next operation you perform with <TT>t</TT> is likely to fail.<BR>
<BR>
Before using list methods and operators, you should read the
documentation carefully and then test them in interactive mode. The
methods and operators that lists share with other sequences (like
strings) are documented at
<TT>docs.python.org/lib/typesseq.html</TT>. The
methods and operators that only apply to mutable sequences
are documented at <TT>docs.python.org/lib/typesseq-mutable.html</TT>.</FONT><BR>
<BR>
<LI><FONT COLOR=black>Pick an idiom and stick with it.<BR>
<BR>
Part of the problem with lists is that there are too many
ways to do things. For example, to remove an element from
a list, you can use <TT>pop</TT>, <TT>remove</TT>, <TT>del</TT>,
or even a slice assignment.<BR>
<BR>
To add an element, you can use the <TT>append</TT> method or
the <TT>+</TT> operator. But don't forget that these are right: 
</FONT><PRE><FONT SIZE=4 COLOR=blue>
t.append(x)
t = t + [x]
</FONT></PRE>
<FONT COLOR=black>And these are wrong:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
t.append([x])          # WRONG!
t = t.append(x)        # WRONG!
t + [x]                # WRONG!
t = t + x              # WRONG!
</FONT></PRE>
<FONT COLOR=black>Try out each of these examples in interactive mode to make sure
you understand what they do. Notice that only the last
one causes a runtime error; the other three are legal, but they
do the wrong thing.</FONT><BR>
<BR>
<LI><FONT COLOR=black>Make copies to avoid aliasing.<BR>
<BR>
<A NAME="@default569"></A>
<A NAME="@default570"></A><BR>
<BR>
If you want to use a method like <TT>sort</TT> that modifies
the argument, but you need to keep the original list as
well, you can make a copy.
</FONT><PRE><FONT SIZE=4 COLOR=blue>
orig = t[:]
t.sort()
</FONT></PRE>
<FONT COLOR=black>In this example you could also use the built-in function <TT>sorted</TT>,
which returns a new, sorted list and leaves the original alone.
But in that case you should avoid using <TT>sorted</TT> as a variable
name!</FONT><BR>
<BR>
<LI><FONT COLOR=black>Lists, <TT>split</TT>, and files<BR>
<BR>
When we read and parse files, there are many opportunities
to encounter input that can crash our program so it is a good 
idea to revisit the <B>guardian</B> pattern when it comes
writing programs that read through a file 
and look for a ``needle in the haystack''.<BR>
<BR>
Let's revisit our program that is looking for the day of the
week on the from lines of our file:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
From stephen.marquard@uct.ac.za <B> Sat</B> Jan  5 09:14:16 2008
</FONT></PRE><FONT SIZE=4>

</FONT><FONT SIZE=3 COLOR=black>Since we are breaking this line into words, we could dispense
with the use of <TT>startswith</TT> and simply look at the 
first word of the line to determine if we are interested
in the line at all. We can use <TT>continue</TT> to skip lines
that don't have ``From'' as the first word as follows:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
fhand = open('mbox-short.txt')
for line in fhand:
    words = line.split()
    if words[0] != 'From' : continue
    print words[2]
</FONT></PRE><FONT COLOR=black>This looks much simpler and we don't even need to do the 
<TT>rstrip</TT> to remove the newline at the end of the file.
But is it better?
</FONT><PRE><FONT SIZE=4 COLOR=blue>
python search8.py 
Sat
Traceback (most recent call last):
  File "search8.py", line 5, in &lt;module&gt;
    if words[0] != 'From' : continue
IndexError: list index out of range
</FONT></PRE><FONT COLOR=black>It kind of works and we see the day from the first line
(Sat) but then the program fails with a traceback error.
What went wrong? What messed-up data caused our elegant, 
clever and very Pythonic program to fail?<BR>
<BR>
You could stare at it for a long time and puzzle through
it or ask someone for help, but the quicker and smarter
approach is to add a <TT>print</TT> statement. The best place
to add the print statement is right before the line where
the program failed and print out the data that seems to be causing
the failure.<BR>
<BR>
Now this approach may generate a lot of lines of output but at 
least you will immediately have some clue as to the 
problem at hand. So we add a print of the variable
<TT>words</TT> right before line five. We even 
add a prefix ``Debug:'' to the line so we can keep
our regular output separate from our debug output.
</FONT><PRE><FONT SIZE=4 COLOR=blue>
for line in fhand:
    words = line.split()
    print 'Debug:', words
    if words[0] != 'From' : continue
    print words[2]
</FONT></PRE><FONT COLOR=black>When we run the program, a lot of output scrolls off the screen
but at the end, we see our debug output and the traceback so 
we know what happened just before the traceback.
</FONT><PRE><FONT SIZE=4 COLOR=blue>
Debug: ['X-DSPAM-Confidence:', '0.8475']
Debug: ['X-DSPAM-Probability:', '0.0000']
Debug: []
Traceback (most recent call last):
  File "search9.py", line 6, in &lt;module&gt;
    if words[0] != 'From' : continue
IndexError: list index out of range
</FONT></PRE><FONT COLOR=black>Each debug line is printing the list of words which we get
when we <TT>split</TT> the line into words. When the program fails
the list of words is empty <CODE>[]</CODE>. If we open the file in a text editor
and look at the file, at that point it looks as follows:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
X-DSPAM-Result: Innocent
X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000

Details: http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772
</FONT></PRE><FONT COLOR=black>The error occurs when our program encounters a blank line! Of course there
are ``zero words'' on a blank line. Why didn't we think of that 
when we were writing the code. When the code looks for the first
word (<CODE>word[0]</CODE>) to check to see if it matches ``From'', 
we get an ``index out of range'' error.<BR>
<BR>
This of course is the perfect place to add some <B>guardian</B> code 
to avoid checking the first word if the first word is not there.
There are many ways to protect this code, we will choose to 
check the number of words we have before we look at the first word:
</FONT><PRE><FONT SIZE=4 COLOR=blue>
fhand = open('mbox-short.txt')
count = 0
for line in fhand:
    words = line.split()
    # print 'Debug:', words
    if len(words) == 0 : continue
    if words[0] != 'From' : continue
    print words[2]
</FONT></PRE><FONT COLOR=black>First we commented out the debug print statement instead of removing it 
in case our modification fails and we need to debug again. Then we added
a guardian statement that checks to see if we have zero words, and if so, 
we use <TT>continue</TT> to skip to the next line in the file.<BR>
<BR>
We can think of the two <TT>continue</TT> statements as helping us refine
the set of lines which are ``interesting'' to us and which we want 
to process some more. A line which has no words is ``uninteresting'' to 
us so we skip to the next line. A line which does not have ``From''
as its first word is uninteresting to us so we skip it.<BR>
<BR>
The program as modified runs successfully so perhaps it is correct. Our
guardian statement does make sure that the <TT>words[0]</TT> will never fail, 
but perhaps it is not enough. When we are programming, we must always be 
thinking, ``What might go wrong?''.<BR>
</FONT><DIV ALIGN=left><FONT COLOR=black><B>Exercise&nbsp;2</B>&nbsp;&nbsp;<EM>
Figure out which line of the above program is still not properly guarded.
See if you can construct a text file which causes the program to fail
and then modify the program so that the line is properly guarded and 
test it to make sure it handles your new text file.
</EM></FONT></DIV><BR>
<DIV ALIGN=left><FONT COLOR=black><B>Exercise&nbsp;3</B>&nbsp;&nbsp;<EM>
Rewrite the guardian code in the above example without two
<TT>if</TT> statements. Instead use a compound logical expression using the
<TT>and</TT> logical operator with a single <TT>if</TT> statement.
</EM></FONT></DIV></OL>
<A NAME="toc105"></A>
<H2><FONT COLOR=black><A NAME="htoc114">8.15</A>&nbsp;&nbsp;Glossary</FONT></H2>
<DL COMPACT=compact><DT><FONT COLOR=black><B>aliasing:</B></FONT><DD><FONT COLOR=black> A circumstance where two or more variables refer to the same
object.
</FONT><A NAME="@default571"></A><BR>
<BR>
<DT><FONT COLOR=black><B>delimiter:</B></FONT><DD><FONT COLOR=black> A character or string used to indicate where a
string should be split.
</FONT><A NAME="@default572"></A><BR>
<BR>
<DT><FONT COLOR=black><B>element:</B></FONT><DD><FONT COLOR=black> One of the values in a list (or other sequence),
also called items.
</FONT><A NAME="@default573"></A><BR>
<BR>
<DT><FONT COLOR=black><B>equivalent:</B></FONT><DD><FONT COLOR=black> Having the same value.
</FONT><A NAME="@default574"></A><BR>
<BR>
<DT><FONT COLOR=black><B>index:</B></FONT><DD><FONT COLOR=black> An integer value that indicates an element in a list.
</FONT><A NAME="@default575"></A><BR>
<BR>
<DT><FONT COLOR=black><B>identical:</B></FONT><DD><FONT COLOR=black> Being the same object (which implies equivalence).
</FONT><A NAME="@default576"></A><BR>
<BR>
<DT><FONT COLOR=black><B>list:</B></FONT><DD><FONT COLOR=black> A sequence of values.
</FONT><A NAME="@default577"></A><BR>
<BR>
<DT><FONT COLOR=black><B>list traversal:</B></FONT><DD><FONT COLOR=black> The sequential accessing of each element in a list.
</FONT><A NAME="@default578"></A><BR>
<BR>
<DT><FONT COLOR=black><B>nested list:</B></FONT><DD><FONT COLOR=black> A list that is an element of another list.
</FONT><A NAME="@default579"></A><BR>
<BR>
<DT><FONT COLOR=black><B>object:</B></FONT><DD><FONT COLOR=black> Something a variable can refer to. An object
has a type and a value.
</FONT><A NAME="@default580"></A><BR>
<BR>
<DT><FONT COLOR=black><B>reference:</B></FONT><DD><FONT COLOR=black> The association between a variable and its value.
</FONT><A NAME="@default581"></A></DL>
<A NAME="toc106"></A>
<H2><FONT COLOR=black><A NAME="htoc115">8.16</A>&nbsp;&nbsp;Exercises</FONT></H2><BR>
<DIV ALIGN=left><FONT COLOR=black><B>Exercise&nbsp;4</B>&nbsp;&nbsp;<EM>
Download a copy of the file from 
<TT>www.py4inf.com/code/romeo.txt</TT><BR>
<BR>
Write a program to open the file <TT>romeo.txt</TT> and read it
line by line. For each line, split the line into a list of 
words using the <TT>split</TT> function.<BR>
<BR>
For each word, check to see if the word is already in a list. 
If the word is not in the list, add it to the list. <BR>
<BR>
When the program completes, sort and print the resulting words
in alphabetical order.
</EM></FONT><PRE><FONT COLOR=black><EM>
Enter file: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 
'and', 'breaks', 'east', 'envious', 'fair', 'grief', 
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft', 
'sun', 'the', 'through', 'what', 'window', 
'with', 'yonder']
</EM></FONT></PRE></DIV><BR>
<DIV ALIGN=left><FONT COLOR=black><B>Exercise&nbsp;5</B>&nbsp;&nbsp;<EM>
Write a program to read through the mail box data and when you find 
line that starts with ``From'', you will split the line into 
words using the <TT>split</TT> function. We are interested in 
who sent the message which is the second word on the From line.<BR>
<BR>
<TT>From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008 </TT><BR>
<BR>
You will parse the From line and print out the second word for 
each From line and then you will also count the number of 
From (not From:) lines and print out a count at the end.<BR>
<BR>
This is a sample good output with a few lines removed:
</EM></FONT><PRE><FONT SIZE=4 COLOR=blue><EM>
python fromcount.py 
Enter a file name: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...some output removed...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
There were 27 lines in the file with From as the first word
</EM></FONT></PRE></DIV><BR>
<DIV ALIGN=left><FONT COLOR=black><B>Exercise&nbsp;6</B>&nbsp;&nbsp;<EM>
Rewrite the program that prompts the user for a list of 
numbers and prints out the maximum and minimum of the
numbers at the end when the user enters ``done''. Write
the program to store the numbers the user enters in a list
and use the <TT>max()</TT> and <TT>min()</TT> fuctions to 
compute the maximum and minimum numbers after the 
loop completes.
</EM></FONT><PRE><FONT SIZE=4 COLOR=blue><EM>
Enter a number: 6
Enter a number: 2
Enter a number: 9
Enter a number: 3
Enter a number: 5
Enter a number: done
Maximum: 9.0
Minimum: 2.0
</EM></FONT></PRE></DIV><BR>
<HR>
<A HREF="cfbook008.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="cfbook010.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
