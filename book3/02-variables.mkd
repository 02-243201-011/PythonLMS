Variáveis, expressões e declarações
======================================

Valores e tipos
----------------

\index{valor}
\index{tipo}
\index{string}
Um *valor* é uma das coisas mais básicas trabalhadas por um programa, como uma letra ou um número. Os valores que vimos até aqui foram
1, 2, e "Alo, Mundo!"


Esses valores pertencem a diferentes *tipos*:
2 é um inteiro, e "Alô, Mundo!" é uma *string*,
assim chamada pois contém uma "string" de letras. Você (e o interpretador) podem identificar
string porque elas são demarcadas com aspas.

\index{Aspas}

A sentença `print` também funciona para inteiros. Usamos o comando
`python` para inicializar o interpretador.

~~~~ {.python}
python
>>> print(4)
4
~~~~

Se você não está tão certo sobre qual é o tipo de um valor, o interpretador pode te falar.

~~~~ {.python .trinket height="160"}
>>> type('Hello, World!')
<class 'str'>
>>> type(17)
<class 'int'>
~~~~


Sem muita surpresa, strings são do tipo `str` e inteiros são do tipo `int`.  Um pouco menos óbvio, números com casas decimais são do tipo `float`,
porque esses números são representados em um formato chamado *ponto flutuante*.


\index{tipo}
\index{tipo string}
\index{class!str}
\index{tipo int}
\index{class!int}
\index{tipo float}
\index{class!float


~~~~ {.python .trinket height="120"}
>>> type(3.2)
<class 'float'>
~~~~


Mas o que dizer sobre valores como "17" e "3.2"?
Eles parecem números, mas estão demarcados com aspas assim como as strings.

\index{aspas}

~~~~ {.python .trinket  height="160"}
>>> type('17')
<class 'str'>
>>> type('3.2')
<class 'str'>
~~~~

Eles são strings.

Quando você digita um inteiro muito grande, você deve estar tentado a usar uma vírgula entre grupos de três dígitos 1,000,000. Isso não é um inteiro válido em Python, mas é válido:

~~~~ {.python .trinket height="120"}
>>> print(1,000,000)
1 0 0
~~~~


Bom, não é o que esperávamos!  Python interpreta 1,000,000 como uma sequência de inteiros separada por vírgulas, a qual é mostrada com um espaço entre cada inteiro.

index{erro semântico}
\index{error!semantic}
\index{mensagem de erro}


Esse é o primeiro exemplo em que vemos um erro semântico: o código é executado sem mostrar nenhuma mensagem de erro, mas não faz a coisa "certa".

Variáveis
---------

\index{variável}
\index{declaração por atribuição}
\index{declaração!atribuição}


Um dos recursos mais poderosos da linguagem de programação é a capacidade de manipular *variáveis*. Uma variável é um nome que faz referência a um valor.

Uma *declaração por atribuição* cria novas variáveis e atribui valores a elas:

~~~~ {.python}
>>> message = 'E agora, para algo completamente diferente'
>>> n = 17
>>> pi = 3.1415926535897931
~~~~


Neste exemplo, foram feitas três atribuições. A primeira designa uma string para uma nova variável chamada `mensagem`; a segunda atribui o valor inteiro 17 para `n`; a terceira atribui o valor (aproximado) de $\pi$ para a variável `pi`. 

Para mostrar o valor de uma variável, você pode usar um comando print:

~~~~ {.python}
>>> print(n)
17
>>> print(pi)
3.141592653589793
~~~~

O tipo de uma variável corresponde ao tipo do valor ao qual ela se refere.

~~~~ {.python}
>>> type(message)
<class 'str'>
>>> type(n)
<class 'int'>
>>> type(pi)
<class 'float'>
~~~~

Nomes de variáveis e palavras-chave
---------------------------

\index{keyword}

Os programadores geralmente escolhem nomes para suas variáveis que são significativos e documentam para que a variável vai ser usada.

Nomes de variáveis podem ser arbitrariamente longos. Elas podem conter letras e números, mas elas não podem começar com um número. É válido usar letras maiúsculas, mas é uma boa ideia começar nomes de variáveis com uma letra minúscula (você verá o porquê mais tarde).

O caractere de sublinhado ( \_ ) pode aparecer em um nome. É frequentemente usado em nomes com
várias palavras, such as
`my_name` or `airspeed_of_unladen_swallow`. 
Nomes de variáveis podem começar com um caractere sublinhado, mas é bom evitar fazer isso a menos que se esteja escrevendo um código de biblioteca para outros.

\index{caractere underscore}

Se você fornecer uma variável com nome inválido, você obter um erro de sintaxe:

~~~~ {.python .trinket height="450"}
>>> 76trombones = 'grande desfile'
SyntaxError: invalid syntax
>>> mais@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
~~~~

`76trombones` é inválido porque começa com um número.
`mais@` é inválido porque contém um caractere irregular, @. Mas o que há de errado com `class`?


Acontece que `class` é uma das *palavras-chave* do Python. O
interpretador  usa palavras-chave para reconhecer a estrutura do programa, e eles não podem ser usados como nomes de variáveis.

\index{palavra-chave}

Python reserva 33 palavras-chave para o seu uso:

~~~~
and       del       from      None      True
as        elif      global    nonlocal  try
assert    else      if        not       while
break     except    import    or        with
class     False     in        pass      yield
continue  finally   is        raise
def       for       lambda    return
~~~~

Talvez você queira manter esta lista à mão. Se o interpretador  reclamar sobre um de seus nomes de variáveis e você não sabe por quê, veja se ele está nesta lista.

Declarações
----------


 Uma *declaração* é uma parte do código que o Python interpreta e pode executar. Nós temos visto dois tipos de declarações: print como uma declaração ou uma atribuição. 

\index{declaração}
\index{modo interativo}
\index{modo script}

Quando você digita uma declaração no modo interativo, o interpretador  a executa e exibe os resultados, se houver um.

Um  script geralmente contém uma sequência de declarações. Se houver mais de uma declaração, os resultados aparecerão à medida que as instruções são executadas.


\index{statement}
\index{interactive mode}
\index{script mode}



Por exemplo, o script 

~~~~ {.python}
print(1)
x = 2
print(x)
~~~~

produz a saída

~~~~
1
2
~~~~

A declaração por atribuição não produz saída.

Operadores e operandos
----------------------

\index{operador, aritimético}
\index{operador aritimético}
\index{operando}
\index{expressão}

*Operadores* são símbolos especiais que representam operações como adição e multiplicação. Os valores em que o operador é aplicado são chamados  *operandos*.

Os operadores `+`, `-`, `*`, `/`, e `**` realizam respectivamente adição, subtração, multiplicação, divisão, e exponenciação, como nos seguintes exemplos:


~~~~ {.python}
20+32
hora-1
hora*60+minuto
minuto/60
5**2
(5+9)*(15-7)
~~~~


Houve uma mudança no operador de divisão entre Python 2.x e Python 3.x. Em Python 3.x, a resposta dessa divisão é um resultado com ponto flutuante:

~~~~ {.python .trinket height="160"}
>>> minuto = 59
>>> minuto/60
0.9833333333333333
~~~~


O operador de divisão em Python 2.x dividiria dois inteiros e truncaria o resultado para um inteiro:

~~~~ {.python}
>>> minute = 59
>>> minute/60
0
~~~~

Para obter a mesma resposta em Python 3.x use a divisão inteira(//inteiro).

~~~~ {.python .trinket  height="160"}
>>> minute = 59
>>> minute//60
0
~~~~


Em Python 3.x a divisão de números inteiros funciona de maneira muito mais semelhante ao que você esperaria se colocasse a expressão em uma calculadora.

\index{Python 3.0}
\index{Python 2.0}
\index{divisão ponto flutuante}
\index{divisão!ponto flutuante}

Expressões
-----------

Uma *expressão* é uma combinação de valores, variáveis e operadores. Um valor, por si só, é considerado uma expressão, assim como uma variável. O que será apresentado a seguir são expressões válidas (assumindo que tenha sido atribuído um valor à variável `x`)

\index{expressão}
\index{avaliar}


~~~~ {.python}
17
x
x + 17
~~~~

Se você digitar uma expressão no modo interativo, o interpretador a {\it avaliará} e mostrará o resultado:

~~~~ {.python}
>>> 1 + 1
2
~~~~

Mas em um script, uma expressão, por si só, não faz nada! Isto geralmente causa muita confusão com iniciantes. 

**Exercício 1: Digite as expressões a seguir no interpretador Python para ver o que elas fazem:**

~~~~ {.python}
5
x = 5
x + 1
~~~~

Ordem das operações
-------------------

\index{ordem das operações}
\index{regras de precedência}
\index{PEMDAS}

Quando mais de um operador aparece em uma expressão, a ordem de avaliação depende das *regras de precedência*. Para operadores matemáticos, o Python segue a convenção matemática. A sigla *PEMDAS* é uma maneira útil de lembrar as seguintes regras:

\index{parênteses!precedência dominante }

-   *P*arênteses têm a precedência mais alta e podem ser utilizados para que forçar uma expressão a ser avaliada na ordem desejada. Como as expressões em parênteses são avaliadas primeiro, `2 * (3-1)` é 4, e `(1+1)**(5-2)`é 8. Você também pode usar parênteses para tornar uma expressão mais fácil de ser lida, como em `(minutos * 100) / 60`, mesmo que isto não resulte em uma mudança no resultado final.

-   *E*xponenciação tem a segunda precedência mais alta, então
`2**1+1` é 3, não 4, e `3*1**3` é 3, não 27.

-   *M*ultiplicação e *D*ivisão possuem a mesma precedência,
que é maior que a *A*dição e *S*ubtração, que também têm a mesma precedência.  Então `2*3-1` é 5, não 4, e
`6+4/2` é 8, não 5.

-   Operadores com a mesma precedência são avaliados da esquerda para direita. Desta maneira, a expressão `5-3-1` é 1, não 3, pois a opreção `5-3`zzzz acontece primeiro e só posteriormente `1` é subtraído do `2`.

Quando estiver em dúvida sobre como o computador vai interpretar uma operação, sempre coloque os parênteses nas suas expressões para garantir que os cálculos serão executados na ordem que você pretende.


Operador de módulo
----------------


\index{operador de módulo}
\index{operador!módulo}

O *operador de módulo* funciona em inteiros e produz o restante quando o primeiro operando é dividido pelo segundo. Em Python, o operador módulos é um sinal de porcentagem `%`.  a sintaxe é a mesma que para outros operadores:


~~~~ {.python .trinket height="240"}
>>> quociente = 7 // 3
>>> print(quociente)
2
>>> resto = 7 % 3
>>> print(resto)
1
~~~~

Assim 7 dividido por 3 é 2 com resto 1 .

O operador de módulo acaba por ser surpreendentemente útil.  Para
exemplo, você pode verificar se um número é divisível por outro: se
`x \% y` é zero, então `x` é divisível por `y`.

\index{divisibilidade}

Você também pode extrair o dígito ou os dígitos mais à direita de um número. Por exemplo, `x \% 10` retorna o dígito mais à direita de `x` (na base 10). Similar, `x \% 100`
retorna os dois últimos dígitos.


Operações com String
-----------------

\index{operações com string}
\index{operador!string}

The `+` operator works with strings, but it is not addition
in the mathematical sense. Instead it performs
*concatenation*, which means joining the strings by
linking them end to end. For example:

\index{concatenation}

~~~~ {.python}
>>> first = 10
>>> second = 15
>>> print(first+second)
25
>>> first = '100'
>>> second = '150'
>>> print(first + second)
100150
~~~~

The `*` operator also works with strings by multiplying the content
of a string by an integer. For example:

~~~~ {.python}
>>> first = 'Test '
>>> second = 3
>>> print(first * second)
Test Test Test
~~~~

Asking the user for input
-------------------------

\index{keyboard input}

Sometimes we would like to take the value for a variable from the user
via their keyboard. Python provides a built-in function called
`input` that gets input from the keyboard^[In Python 2.0, this function was named `raw_input`.]. 
When this function is
called, the program stops and waits for the user to type something. When
the user presses `Return` or `Enter`, the program
resumes and `input` returns what the user typed as a string.

\index{Python 2.0}

~~~~ {.python}
>>> inp = input()
Some silly stuff
>>> print(inp)
Some silly stuff
~~~~

Before getting input from the user, it is a good idea to print a prompt
telling the user what to input. You can pass a string to `input` to
be displayed to the user before pausing for input:

\index{prompt}

~~~~ {.python}
>>> name = input('What is your name?\n')
What is your name?
Chuck
>>> print(name)
Chuck
~~~~

The sequence `\n` at the end of the prompt represents a
*newline*, which is a special character that causes a
line break. That's why the user's input appears below the prompt.

\index{newline}

If you expect the user to type an integer, you can try to convert the
return value to `int` using the `int()` function:

~~~~ {.python}
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
~~~~

But if the user types something other than a string of digits, you get
an error:

~~~~ {.python}
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int() with base 10:
~~~~

We will see how to handle this kind of error later.

\index{ValueError}
\index{exception!ValueError}

Comments
--------

\index{comment}

As programs get bigger and more complicated, they get more difficult to
read. Formal languages are dense, and it is often difficult to look at a
piece of code and figure out what it is doing, or why.

For this reason, it is a good idea to add notes to your programs to
explain in natural language what the program is doing. These notes are
called *comments*, and in Python they start with the `#`
symbol:

~~~~ {.python}
# compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
~~~~

In this case, the comment appears on a line by itself. You can also put
comments at the end of a line:

~~~~ {.python}
percentage = (minute * 100) / 60     # percentage of an hour
~~~~

Everything from the `#` to the end of the line is ignored; it
has no effect on the program.

Comments are most useful when they document non-obvious features of the
code. It is reasonable to assume that the reader can figure out *what*
the code does; it is much more useful to explain *why*.

This comment is redundant with the code and useless:

~~~~ {.python}
v = 5     # assign 5 to v
~~~~

This comment contains useful information that is not in the code:

~~~~ {.python}
v = 5     # velocity in meters/second.
~~~~

Good variable names can reduce the need for comments, but long names can
make complex expressions hard to read, so there is a trade-off.

Choosing mnemonic variable names
--------------------------------

\index{mnemonic}

As long as you follow the simple rules of variable naming, and avoid
reserved words, you have a lot of choice when you name your variables.
In the beginning, this choice can be confusing both when you read a
program and when you write your own programs. For example, the following
three programs are identical in terms of what they accomplish, but very
different when you read them and try to understand them.

~~~~ {.python}
a = 35.0
b = 12.50
c = a * b
print(c)
~~~~

~~~~ {.python}
hours = 35.0
rate = 12.50
pay = hours * rate
print(pay)
~~~~

~~~~ {.python}
x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print(x1q3p9afd)
~~~~

The Python interpreter sees all three of these programs as *exactly the
same* but humans see and understand these programs quite differently.
Humans will most quickly understand the *intent* of the
second program because the programmer has chosen variable names that
reflect their intent regarding what data will be stored in each
variable.

We call these wisely chosen variable names "mnemonic variable names".
The word *mnemonic*^[See <https://en.wikipedia.org/wiki/Mnemonic> for an extended
description of the word "mnemonic".] means "memory aid". We choose mnemonic variable
names to help us remember why we created the variable in the first
place.

While this all sounds great, and it is a very good idea to use mnemonic
variable names, mnemonic variable names can get in the way of a
beginning programmer's ability to parse and understand code. This is
because beginning programmers have not yet memorized the reserved words
(there are only 33 of them) and sometimes variables with names that are
too descriptive start to look like part of the language and not just
well-chosen variable names.

Take a quick look at the following Python sample code which loops
through some data. We will cover loops soon, but for now try to just
puzzle through what this means:

~~~~ {.python}
for word in words:
    print(word)
~~~~

What is happening here? Which of the tokens (for, word, in, etc.) are
reserved words and which are just variable names? Does Python understand
at a fundamental level the notion of words? Beginning programmers have
trouble separating what parts of the code *must* be the same as this
example and what parts of the code are simply choices made by the
programmer.

The following code is equivalent to the above code:

~~~~ {.python}
for slice in pizza:
    print(slice)
~~~~

It is easier for the beginning programmer to look at this code and know
which parts are reserved words defined by Python and which parts are
simply variable names chosen by the programmer. It is pretty clear that
Python has no fundamental understanding of pizza and slices and the fact
that a pizza consists of a set of one or more slices.

But if our program is truly about reading data and looking for words in
the data, `pizza` and `slice` are very un-mnemonic
variable names. Choosing them as variable names distracts from the
meaning of the program.

After a pretty short period of time, you will know the most common
reserved words and you will start to see the reserved words jumping out
at you:

<pre>
<b>for</b> word <b>in</b> words<b>:</b>
    <b>print</b>(word)
</pre>

The parts of the code that are defined by Python (`for`,
`in`, `print`, and `:`) are in bold and
the programmer-chosen variables (`word` and
`words`) are not in bold. Many text editors are aware of
Python syntax and will color reserved words differently to give you
clues to keep your variables and reserved words separate. After a while
you will begin to read Python and quickly determine what is a variable
and what is a reserved word.

Debugging
---------

\index{debugging}

At this point, the syntax error you are most likely to make is an
illegal variable name, like `class` and `yield`,
which are keywords, or `odd~job` and `US$`, which contain illegal
characters.

\index{syntax error}
\index{error!syntax}

If you put a space in a variable name, Python thinks it is two operands
without an operator:

~~~~ {.python}
>>> bad name = 5
SyntaxError: invalid syntax
~~~~

~~~~ {.python}
>>> month = 09
  File "<stdin>", line 1
    month = 09
             ^
SyntaxError: invalid token
~~~~

For syntax errors, the error messages don't help much. The most common
messages are `SyntaxError: invalid syntax` and
`SyntaxError: invalid token`, neither of which is very
informative.

\index{error message}
\index{use before def}
\index{exception}
\index{runtime error}
\index{error!runtime}

The runtime error you are most likely to make is a "use before def;"
that is, trying to use a variable before you have assigned a value. This
can happen if you spell a variable name wrong:

~~~~ {.python}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
~~~~

Variables names are case sensitive, so `LaTeX` is not the
same as `latex`.

\index{case-sensitivity, variable names}
\index{semantic error}
\index{error!semantic}

At this point, the most likely cause of a semantic error is the order of
operations. For example, to evaluate $1/2\pi$, you might be
tempted to write

~~~~ {.python}
>>> 1.0 / 2.0 * pi
~~~~

But the division happens first, so you would get $\pi / 2$, which is not
the same thing! There is no way for Python to know what you meant to
write, so in this case you don't get an error message; you just get the
wrong answer.

\index{order of operations}

Glossary
--------

assignment
:   A statement that assigns a value to a variable.
\index{assignment}

concatenate
:   To join two operands end to end.
\index{concatenation}

comment
:   Information in a program that is meant for other programmers (or
    anyone reading the source code) and has no effect on the execution
    of the program.
\index{comment}

evaluate
:   To simplify an expression by performing the operations in order to
    yield a single value.

expression
:   A combination of variables, operators, and values that represents a
    single result value.
\index{expression}

floating point
:   A type that represents numbers with fractional parts.
\index{floating-point}

integer
:   A type that represents whole numbers.
\index{integer}

keyword
:   A reserved word that is used by the compiler to parse a program; you
    cannot use keywords like `if`, `def`, and
    `while` as variable names.
\index{keyword}

mnemonic
:   A memory aid. We often give variables mnemonic names to help us
    remember what is stored in the variable.
\index{mnemonic}

modulus operator
:   An operator, denoted with a percent sign (`%`), that
    works on integers and yields the remainder when one number is
    divided by another.
\index{modulus operator}
\index{operator!modulus}

operand
:   One of the values on which an operator operates.
\index{operand}

operator
:   A special symbol that represents a simple computation like addition,
    multiplication, or string concatenation.
\index{operator}

rules of precedence
:   The set of rules governing the order in which expressions involving
    multiple operators and operands are evaluated.
\index{rules of precedence}
\index{precedence}

statement
:   A section of code that represents a command or action. So far, the
    statements we have seen are assignments and print expression statement.
\index{statement}

string
:   A type that represents sequences of characters.
\index{string}

type
:   A category of values. The types we have seen so far are integers
    (type `int`), floating-point numbers (type
    `float`), and strings (type `str`).
\index{type}

value
:   One of the basic units of data, like a number or string, that a
    program manipulates.
\index{value}

variable
:   A name that refers to a value.
\index{variable}

Exercises
---------

**Exercise 2: Write a program that uses `input` to prompt a user for
their name and then welcomes them.**

~~~~
Enter your name: Chuck
Hello Chuck
~~~~

**Exercise 3: Write a program to prompt the user for hours and rate per
hour to compute gross pay.**

~~~~
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
~~~~

We won't worry about making sure our pay has exactly two digits after
the decimal place for now. If you want, you can play with the built-in
Python `round` function to properly round the resulting pay
to two decimal places.

**Exercise 4: Assume that we execute the following assignment statements:**

~~~~
width = 17
height = 12.0
~~~~

For each of the following expressions, write the value of the expression
and the type (of the value of the expression).

1.  `width//2`

2.  `width/2.0`

3.  `height/3`

4.  `1 + 2 * 5`

Use the Python interpreter to check your answers.

**Exercise 5: Write a program which prompts the user for a Celsius
temperature, convert the temperature to Fahrenheit, and print out the
converted temperature.**

